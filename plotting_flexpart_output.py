"""
Created on Mon Feb 17 10:59:06 2020

@author: eelk
"""


from netCDF4 import Dataset
import numpy as np
import matplotlib.pyplot as plt
import matplotlib as mpl
from mpl_toolkits.basemap import Basemap
import dateutil.parser as dateparse
from datetime import timedelta
from sys import stderr, exit
import argparse
from os import path, makedirs

class ArgumentsError(Exception):
    '''
    Exception raised when there is an error detected in the argument list.
    '''
    def __init__(self, msg):
        stderr.write('[FATAL ERROR] : %s' % msg )
        exit(9)


class FatalError(Exception):
    '''
    Exception raised when there is an unrecoverable error encountered.
    '''
    def __init__(self, msg):
        stderr.write('[FATAL ERROR] : %s' % msg )
        exit(9)


class FileError(Exception):
    '''
    Exception raised when contents of files are not as expected
    '''
    def __init__(self,msg):
        stderr.write('[FILE ERROR] : %s' % msg )
        exit(9)

def getargs():
    '''
    Plotting data generated by FLEXPART run between two dates -
    Retrieves the two dates from command line arguments.

    In : None
    Out: Date(s) of data in "YYYY-MM-DD" format
    '''

    parser = argparse.ArgumentParser(description=(
        'Retrieve data from ECMWF and convert to RELEASES text format.\n'+
        'Requires date for GFAS data in YYYY-MM-DD format as input argument.'
        ))

    parser.add_argument('startdate',
                        type=str,
                        help='[REQUIRED]\nFirst date for which data is available. Should be in format "YYYY-MM-DD"\n'+
                             'If data from only one date required, give that date here')

    parser.add_argument('datapath',
                        type=str,
                        help='Location of FLEXPART nc file. PNGs will be put here also.')

    args = parser.parse_args()

    # Validate the date

    startdate=dateparse.parse(args.startdate).date()

    if ( startdate.year != int(args.startdate[:4]) and startdate.month <= 12 and startdate.day <= 12 ):
        raise ArgumentsError("Start date was not in ISO 8601 format (YYYY-MM-DD), and date "+
        "parser cannot infer true date as both month and day are below 12 and "+
        "could be month-first or day-first format.\n"+
        "Please retry using the recommended ISO 8601 format (YYYY-MM-DD)")
    else:
        strtstr = startdate.strftime("%Y%m%d")

    # Validate the output path, or generate it from default value

    datapath = args.datapath

    if not path.exists(datapath):
        print('Directory to write gfs files to'
              + ' does not exist\nAttempting to create:')
        try:
            makedirs(datapath)
        except:
            raise FatalError('Could not create directory '+ datapath +'\n')
        else:
            print ("Success!\n")

    if datapath and not path.isdir(datapath):
        raise FatalError(datapath + ' exists but is not a directory\n')


    return (strtstr,datapath)


def main():

    (date,datapath) = getargs()

    flex_file = Dataset(path.join(datapath,'grid_conc_'+date+'000000.nc'),'r+',format='NETCDF4')
    lat = flex_file.variables['latitude'][:]
    lon = flex_file.variables['longitude'][:]
    time = flex_file.variables['time'][:]  ##in seconds from start date
    height = flex_file.variables['height'][:]
    trace = flex_file.variables['spec002_mr'][0,0,:,:,:,:]/1000  #ug/m3
    CO = flex_file.variables['spec001_mr'][0,0,:,:,:,:]/1000 #ug/m3
    PM25 = flex_file.variables['spec003_mr'][0,0,:,:,:,:]/1000 #ug/m3
    flex_file.close()

        ##average up to 20m###
    for l in range(0,2):
        if l ==0:
            h = height[l]
        else:
            h = height[l]- height[l-1]
        PM25[:,l,:,:] = PM25[:,l,:,:]*h  #multiply by meters in each height level to get it in ug/m2
        CO[:,l,:,:] = CO[:,l,:,:]*h
        trace[:,l,:,:] = trace[:,l,:,:]*h
    PM25 = np.sum(PM25[:,0:l+1,:,:],axis = 1)/height[l]  ##add up heights up to 20m, then divide by 20 to get it back in ug/m3
    CO = np.sum(CO[:,0:l+1,:,:],axis = 1)/height[l]

    startdate=dateparse.parse(date)

    for i in range(0,len(time)):
        ###Map plot of each 3 hour timestep - labelled as time from start date ###
        ###To make video from plots use:  ffmpeg -r 2 -f image2 -s 1920x1080 -i PM25_map_%d.png -vcodec libx264 -crf 25  -pix_fmt yuv420p PM25_2015.mp4
        filedate = startdate + timedelta(0,int(time[i]))
        ax = plt.figure(figsize = (14,7))
        plt.rcParams.update({'font.size': 13})
        vals = np.array([25,50,100,150,200,250,300,350,400,450,500,600,700,800,900,1000,1500,2000,2500,3000,3500,4000,4500,5000,6000,7000,8000,10000,15000,20000])
        vals = vals/200
        cmap = plt.get_cmap('RdYlBu_r', 100)
        newcolors = cmap(np.linspace(0, 1, 100))
        newcmp = mpl.colors.ListedColormap(newcolors)
        norm = mpl.colors.BoundaryNorm(vals,newcmp.N)
        m = Basemap(projection='merc',llcrnrlon=88.,llcrnrlat=-17.,urcrnrlon=132.,urcrnrlat=27.,resolution='i')
        m.drawcoastlines(linewidth=2)
        m.drawmapboundary(linewidth=0.5)
        #m.drawparallels(np.arange(-10,11,5),labels=[1,0,0,0], linewidth=0.0)
        xx, yy = np.meshgrid(lon, lat )
        x , y = m(xx,yy)
        m.pcolormesh(x,y,PM25[i,:,:],shading='flat',cmap=newcmp, norm = norm)
        plt.title('PM2.5 20m (ug/m3)')
        plt.text(1,1,filedate.strftime("%Y-%m-%d %H:%M"))
        cbar_ax = plt.axes([0.02, 0.05, 0.95, 0.03])
        plt.colorbar(cax=cbar_ax, orientation='horizontal', extend = 'both') #, label = 'ug/m3')
        filedate = startdate + timedelta(0,int(time[i]))
        plt.savefig(path.join(datapath,'PM25_above20_gfs_ecmwf_map_'+filedate.strftime("%Y%m%d%H%M")+'.png'))
        plt.close()
